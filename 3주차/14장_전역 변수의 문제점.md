# 14장. 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 번수의 생명 주기

번수 선언은 자바스크립트 엔진의 **평가 단계**에서 일어나기 때문에 런타임 이전에 실행

이 때 지역변수(local variable)는 함수 호출 시 생성되었다가 함수가 종료하면 변수가 소멸되므로 ***지역 변수의 생명 주기는 함수의 생명주기와 일치***
(단, 클로저의 경우 지역 변수가 함수보다 오래 생존 가능)

- 호이스팅은 스코프를 단위로 동작 : 따라서 전역 변수는 전역 스코프로, 지역 변수는 지역 스코프에 등록되기 때문에 마치 스코프의 선두로 끌어 올려진 것처럼 동작하는데 이를 **호이스팅**이라 함

### 14.1.2 전역 변수의 생명 주기

> 전역 객체 : 코드 실행 이전에 엔진에 의해 제일 먼저 생성되는 특수 객체
> > 브라우저에서는 window, 서버 사이드 환경(Node.js)에서는 global이나 ES11에서 globalThis로 통일!

전역 변수는 전역 객체의 스코프에 생성되며, var 키워드로 선언된 변수는 전역 변수가 되기 때문에 var 변수의 생명주기는 전역 객체의 생명주기와 일치


## 14.2 전역 변수의 문제점

엔지니어에게 가장 치명적인 ***예상치 못한 상황***을 만들 가능성이 너무 많아 사용하지 않는 것을 권장

- 암묵적 결합(implicit coupling) : 모든 코드가 전역 변수를 참조하고 변경 가능

- 긴 생명주기 : 메모리 낭비, 의도치 않은 재할당 가능성 존재

- 스코프 체인 상에서 종점에 존재 : 변수의 검색 속도가 느리며, 의도지 않은 버그 발생 가능

- 네임스페이스 오염 : 분리된 파일간의 스코프 공유로 인해 전혀 다른 파일에서도 접근 가능


## 14.3 전역 변수의 사용을 억제하는 방법

### 14.3.1 즉시 실행 함수(IIFE; Immediately Invoked Function Expression)

코드를 즉시 실행 함수로 감싸면 내부의 변수는 지역 변수가 되기 때문에 전역 변수의 사용을 억제할 수 있음

라이브러리 등에 자주 사용

> 그룹 연산자 & 함수 호출 연산자 ( ( <- 이놈 ) : 내부의 문을 식으로 판단하는데 함수가 들어오게 되면 암묵적으로 식별자를 생성하고 코드블록 끝의 () 함수 호출 연산자로 인해 해당 함수가 바로 실행됨

> 수종 : 사실 const, let을 사용 가능하고, 메모리도 빵빵하며, 리액트 등의 프레임워크의 시대에 꼭 써야 하는 방법은 아니라 생각하나 문제 해결의 아이디어로서 알아둘만 한듯

### 14.3.2 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법

네임스페이스 객체 자체가 전역에 할당되니 즉시실행 함수만큼 메모리 관리가 되진 않음

### 14.3.3 모듈 패턴(추천!! 강추!! 좋아요!!)

> 캡슐화 : 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것, 정보 은닉!

즉시실행 함수 내부의 변수는 private, 반환하는 객체의 프로퍼티는 public이 되기 때문에 이전의 문제들을 해결 가능

### 14.3.4 ES6 모듈

계속 이렇게 private을 쓰고싶어하니까 ES6에서는 모듈 스코프를 공식적으로 제공

모듈 내에서 선언한 변수는 모듈 스코프에 등록되어 전역 변수가 아니게 됨
